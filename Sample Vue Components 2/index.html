<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<style media="screen">

</style>
<body>
  <div id="app">
    <!--By default, v-model on a component uses value
    as the prop and input as the event-->
    <currency-input v-model="price"></currency-input>

    <my-checkbox v-model="foo" value="some value"></my-checkbox>

  </div>
</body>


<script src="../Local_Vue/vue.js"></script>
<script type="text/javascript">
// 1.-Form Input Components using Custom Events
Vue.component('currency-input', {
  template: // ref is a property that we can use to later refer to our element
  `
  <span>
  $ <input ref="input"  v-on:input="updateValue($event.target.value)">
  </span>
  `,
  props: ['value'],
  methods: {
    // Instead of updating the value directly, this
    // method is used to format and place constraints
    // on the input's value
    updateValue: function (value) {
      var formattedValue = value
      // Remove whitespace on either side
      .trim()
      // Shorten to 2 decimal places
      .slice( 0, value.indexOf('.') === -1 ? value.length : value.indexOf('.') + 3 )
      // If the value was not already normalized,
      // manually override it to conform
      if (formattedValue !== value) {
        // $ref.<<value of property ref>> gets us
        // the html element with that value
        this.$refs.input.value = formattedValue
      }
      // Emit the number value through the input event
      // doing so, we can use the v-model to notify mutations
      this.$emit( 'input' , formattedValue );
    }
  }
});
// 2.-Customizing Component v-model
Vue.component('my-checkbox', {
  template:
  `
  <div>
  <input ref="input" type="checkbox" v-bind:checked="inputChecked" v-on:change="updateValue($event.target.checked)"
  name="vehicle" v-bind:value="value"> I have a bike
  <br>
  </div>
  `,
  // By default, v-model on a component uses value
  // as the prop and input as the event
  model: {
    prop: 'checked',
    event: 'input'
  },
  props: {
    checked: Boolean,
    // this allows using the `value` prop for a different purpose
    value: String
  },
  computed:{
    inputChecked: function() {
      return this.checked
    }
  },
  methods: {
    updateValue: function (value) {
      console.log(this.value);
       console.log(value);
       this.$emit( 'input' , value );
    }
  },
  watch: {
  }
});
// create a root instance
new Vue({
  el: '#app',
  data: {
    price:"",
    foo:true
  }, // data Ends
  methods: {
    _price: function(){
      console.log("Changed in the parent too");
      console.log(this.price);
    },
    _foo: function(){
      console.log("Changed in the parent too");
      console.log(this.foo);
    }
  }, // methods Ends
  computed:{
  }, // computed Ends
  watch:{
    price:"_price",
    foo:"_foo"
  } // watch Ends
});
</script>
</html>
